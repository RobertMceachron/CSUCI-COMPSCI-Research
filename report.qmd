---
title: "An analysis of undergraduate major graduation rates within the department of computer science at CSUCI"
subtitle: "MATH 398 (Fall 2025)"
author: "Monique Calatayud, Robert McEachron, and Morgan McMurray"
format: 
  html:
    df-print: paged
    toc: true
    toc-expand: 2
    toc-location: left
    embed-resources: true
execute:
  warning: false
  message: false
editor: 
  markdown: 
    wrap: 72
knitr:
  opts_chunk:
    message: false
    warning: false
---

# Introduction

Despite ongoing efforts to increase diversity in the technology sector,
computer science programs continue to be disproportionately represented
by white males. Limited minority representation within the profession
contributes to the exclusion of diverse perspectives in product design,
which can result in algorithmic harm—technology-driven threats to civil
rights and democratic values. Understanding the factors contributing to
under-representation in computer science is therefore critical to
fostering equitable and inclusive technological development. To the best
of our knowledge, no such analysis has been conducted on students
currently attending California State University Channel Islands (CSUCI),
a Hispanic-Serving Institution.

Thus, the current study will examine demographics among students
enrolled in the Computer Science Program at CSUCI, while painting a
holistic picture of the department. Additionally, factors predicting
graduation rates among students in the program will expose problem areas
necessary for intervention. The findings aim to help CSUCI and similar
institutions design targeted interventions to support at-risk computer
science students, ultimately contributing to a more diverse and
inclusive technology workforce that better serves society as a whole.

# Method

## Data

All code was analyzed using R version 4.5.2.

### Data Description

The data was obtained from the Office of Institutional Research (IR) and
included 1,691 students enrolled in the Department of Computer Science
at California State University Channel Islands (CSUCI) between Fall 2015
and Fall 2025. Fall, Winter, Spring, and Summer terms were included.
There was a total of 11,407 rows, each representing one term for a
student.

The following includes an explanation of our static variables, meaning
they do not change across the student's terms:

```         
  Student: numeric annoymized student identifier
  First_CI_Term: numeric identifier for the term that students started at CI
  First_CI_Term_Desc: word description of First_CI_Term
  First_CS_Term: numeric identifier for the term that students started a major under the Department of Computer Science at CSUCI
  First_CS_Term_Desc: word description of First_CS_Term
  Is_Transfer: binary, 1 for yes, 0 for no
  Did_Graduate: numeric identifier for the term that the student graduated from CSUCI, or 0 if they did not graduate
  Dependent_Income_Code: categorical, values 1-7 representing ranges of the student's parents' gross annual income (if the student was considered a "dependent"), or 8 if there is no response
```

The following variables are time series dependent, meaning the values
are dynamic across each student's terms:

```         
  Term_Code: numeric identifier for term
  Term_Desc: word description of the term that corresponds to Term_Code
  Is_Hispanic: binary; 1 for yes, 0 for no
  Gender: categorical; values include "Man," "Woman," and "Non-Binary"
  major1, major2, major3: character string codes for the major(s) that students had declared during the term in question
  major1 Descr, major2 Descr, major3 Descr: word description(s) of the major(s) in major1, major2, and major3
  Unit_Load: numeric, number of units attempted during a given term
  Lived_On_Campus: binary; 1 for yes, 0 for no
  Num_Tutoring_Visits: integer, total count of visits to LRC, WMC, and STEM Center
```

### Data Cleaning

The following process was conducted to focus on non-current
undergraduate students who declared only one major throughout their
academic trajectory.

To simplify the data, `Term_Desc` and the `major1`-`major3` columns were
removed. The columns `major1 Descr`, `major2 Descr` and `major3 Descr`
were renamed to include underscores for R accessibility.

Multiple remaining rows per student had the same `Term_Code` but
different `Dependent_Income_Code`s. The last unique term row per student
was maintained; the rest were removed (*n* = 2150 rows). Students whose
last term row did not match their graduation term code were also removed
(*n* = 277 rows), as time series variables were not included in their
graduation term. Additionally, current students (*n* = 2,053 rows),
students who declared two or more majors at any term (*n* = 573 rows),
and those who were in a Master's program (*n* = 12 rows) were removed.
After these exclusions, N = 6342 term rows and N = 1091 students
remained.

The `Did_Graduate` column was re-coded to represent students who: did
not graduate ($Did\_Graduate = 0$), graduated with one of the majors
within the computer science program ($Did\_Graduate \neq 0$ and
`major1_Descr` was either `"BS: Computer Science"`, `"BS: Information`
`Technology"`, `"BS: Mechatronics Engineering"`, or
`"BS: Mechatronics"`), or graduated with another major
($Did\_Graduate \neq 0$ and `major1_Descr` was not any of the majors
offered by the Department of Computer Science). Students who either did
not graduate or graduated with a major outside of the Department of
Computer Science were eventually re-coded as 0, and students who
graduated with one of the majors within the computer science program
were eventually re-coded as 1.

Finally, rows corresponding to terms outside of a student's enrollment
in the computer science program were excluded (*n* = 640 rows), leaving
the final dataset for pivoting (N = 5702 rows).

::: {.panel-tabset}

#### Final Cleaning Code

```{r}
# Load necessary libraries
library(tidyverse)
library(readxl)

# Read excel data into dataframe
# Set the max number of rows to use in creating the guess type for each column
# This helps get rid of warnings about guess types mismatching inputs read from the actual rows
# The number of rows used to determine column type is the max because our dataset is sparse
orig_data <- read_excel("CS Major Data 2025-10-10.xlsx", guess_max = min(8400, n_max = NULL))

# Get rid of term description columns and major1, major2, and major3 columns (we have description columns for these instead)
removed_term_descs_and_major_codes <- orig_data %>% 
  select(-one_of("Term_Desc", "First_CI_Term_Desc", "First_CS_Term_Desc", "major1", "major2", "major3"))

# Remove duplicates, retain last of near-duplicate rows (1 row per term per student)
de_duped_reduced <- removed_term_descs_and_major_codes %>% 
  group_by(Student, Term_Code) %>% 
  slice_tail(n = 1) %>% 
  ungroup()

# Rename major description columns to include underscores (makes them easier to work with)
names(de_duped_reduced)[which(colnames(de_duped_reduced) == "major1 Descr")] <- "major1_Descr"
names(de_duped_reduced)[which(colnames(de_duped_reduced) == "major2 Descr")] <- "major2_Descr"
names(de_duped_reduced)[which(colnames(de_duped_reduced) == "major3 Descr")] <- "major3_Descr"

# Identify students who graduated, but their last term row doesn't match their graduation code
mismatch <- de_duped_reduced %>% 
  filter(Did_Graduate != 0) %>% 
  group_by(Student) %>% 
  slice_tail(n = 1) %>% 
  filter(Term_Code != Did_Graduate) %>% 
  pull(Student)

# Remove students whose last term row doesn't match their graduation code
ddr_filtered_mismatch <- de_duped_reduced %>% 
  filter(!Student %in% mismatch)

# Identify current students and remove them
# 2258 = "Fall 2025"
ddrfm_removed_current_students <- ddr_filtered_mismatch %>% 
  group_by(Student) %>% 
  filter(!any(Term_Code == 2258)) %>% 
  ungroup()

# Identify and keep single majors, exclude everyone else
only_single_majors <- ddrfm_removed_current_students %>% 
  group_by(Student) %>% 
  filter((all(is.na(major2_Descr)) == TRUE) && (all(is.na(major3_Descr)) == TRUE)) %>%
  ungroup()

# Remove students who graduated with a master's program in computer science
only_undergrads <- only_single_majors %>% 
  group_by(Student) %>% 
  filter(!any(major1_Descr == "MS: Computer Science")) %>% 
  ungroup()

# ------------------------------------------------------------------------------------------------------------------------------------------------
# Re-code "Did_Graduate" to the following scheme:
# 0 --> No
# nonzero AND major1_Descr equals one of: "BS: Computer Science," "BS: Information Technology," "BS: Mechatronics Engineering," "BS: Mechatronics"
# --> Yes, with CS/IT/EMEC
# nonzero AND major1_Descr is anything else 
# --> Yes, with another major
# ------------------------------------------------------------------------------------------------------------------------------------------------

# Get students who did not graduate with majors from the CS program
cs_dept_majors <- c("BS: Computer Science", "BS: Information Technology", "BS: Mechatronics Engineering", "BS: Mechatronics")
students_wo_cs <- only_undergrads %>% 
  group_by(Student) %>% slice_tail(n = 1) %>% 
  filter(!(major1_Descr %in% cs_dept_majors)) %>% 
  ungroup() %>% 
  pull(Student)

# Recode "Did_Graduate" according to the scheme above
recoded_graduation <- only_undergrads %>% 
  group_by(Student) %>% 
  mutate(Did_Graduate = case_when(Did_Graduate == 0 ~ "No",
                                  (Did_Graduate != 0) & (Student %in% students_wo_cs) ~ "Yes, with another major",
                                  TRUE ~ "Yes, with CS/IT/EMEC")) %>% 
  ungroup()

# Exclude all rows outside of when students were enrolled in a program under the department of computer science
only_cs_rows <- recoded_graduation %>% 
  group_by(major1_Descr) %>% 
  filter(major1_Descr %in% cs_dept_majors)

# Reorder columns to put static data in one area of the dataframe, and time-series in the other
cleaned_and_reordered <- only_cs_rows %>% 
  select(Student, Is_Hispanic, Gender, Is_Transfer, Dependent_Income_Code, First_CI_Term, First_CS_Term, major1_Descr, 
         major2_Descr, major3_Descr, Did_Graduate, Term_Code, Unit_Load, Lived_On_Campus, Num_Tutoring_Visits)
```

#### Step Justifications

```{r}
# Load necessary libraries
library(tidyverse)
library(readxl)

# Read excel data into dataframe
# Set the max number of rows to use in creating the guess type for each column
# This helps get rid of warnings about guess types mismatching inputs read from the actual rows
# The number of rows used to determine column type is the max because our dataset is sparse
orig_data <- read_excel("CS Major Data 2025-10-10.xlsx", guess_max = min(8400, n_max = NULL))
```

**Confirmation of entirely duplicate rows:**

```{r}
sum(duplicated(orig_data))
```

**Confirmation of nearly duplicate rows --- and that
`Dependent_Income_Code` was the problem:**

```{r}
orig_data %>% 
  distinct() %>% 
  group_by(Student, Term_Code) %>% 
  add_tally(sort = TRUE) %>% 
  filter(n > 1) %>%
  summarize(n_distinct(Dependent_Income_Code)) %>%
  ungroup()
```

**Confirmation of the presence of students who graduated, but their last
term code did not match their graduation term code:**

```{r}
orig_data %>%
  select(Student, Term_Code, Did_Graduate) %>%
  distinct() %>%
  group_by(Student) %>% 
  slice_tail(n = 1) %>%
  ungroup() %>%
  filter((Did_Graduate > 0) & (Term_Code != Did_Graduate))
  
```

**Confirmation that `Term_Code` 2258 is "Fall 2025":**

```{r}
orig_data %>% 
  select(Term_Code, Term_Desc) %>% 
  distinct() %>%
  filter(Term_Desc == "Fall 2025")
```

:::

### Data Pivoting

The dataset was pivoted to represent one row per student in order to
ensure compatibility with statistical methods and reduce redundancy.

Because the number of terms a student was enrolled in a major from the
Computer Science Program varies by student, dataset pivoting was done
through a for loop that created new rows based on whether a change in
the `Student` column was observed. A detailed walk through of the code
is written below.

The primary statistical method in this analysis is logistic regression.
Since the original data was collected as a time series, independence
(one of the assumptions of logistic regression) was violated. Pivoting
the original dataset such that each observation is an individual student
creates independence and, in part, assures that the assumptions for
logistic regression are met.

Due to the small sample size of non-binary (*n* = 1) students, their
value was re-coded as being female for future analyses. Personal
experience of gender-based marginalization by one of the researchers ---
a non-binary person majoring in computer science --- informed this
decision.

```{r}
# Get first row of all static data columns
static_data <- c("Student", "Is_Hispanic", "Gender", "Is_Transfer", 
                 "Dependent_Income_Code", "First_CI_Term", "First_CS_Term", 
                 "major1_Descr", "major2_Descr", "major3_Descr", "Did_Graduate")

pivoted <- cleaned_and_reordered[1, static_data]

# Get relevant pivoting variables from the first student
# Such that the pivoting loop can be initialized
current_id <- cleaned_and_reordered[1, "Student"]
current_major1 <- cleaned_and_reordered[1, "major1_Descr"]
current_major2 <- cleaned_and_reordered[1, "major2_Descr"]
current_major3 <- cleaned_and_reordered[1, "major3_Descr"]
current_term <- 1
current_entry <- 1

# The loop that pivots the data
for (current_row in 1:nrow(cleaned_and_reordered)) {
  
  # If the current student number is different from the saved student number,
  # Save the new student number and their majors, reset term number,
  # and add a new row with static data
  if (cleaned_and_reordered[current_row, "Student"] != current_id) {
    current_id <- cleaned_and_reordered[current_row, "Student"]
    current_major1 <- cleaned_and_reordered[current_row, "major1_Descr"]
    current_major2 <- cleaned_and_reordered[current_row, "major2_Descr"]
    current_major3 <- cleaned_and_reordered[current_row, "major3_Descr"]
    current_term <- 1
    current_entry <- current_entry + 1
    pivoted[current_entry, ] <- c(cleaned_and_reordered[current_row, static_data], rep(NA, each = (ncol(pivoted) - length(static_data))))
  }
  
  # Initialize the column names for the current term
  # These will be populated with values for the time-dependent variables
  current_col_label <- paste("T", current_term, "_", sep = "")
  current_cols <- c(paste(current_col_label, "Term_Code", sep=""),
                    paste(current_col_label, "Unit_Load", sep=""),
                    paste(current_col_label, "Lived_On_Campus", sep=""),
                    paste(current_col_label, "Num_Tutoring_Visits", sep=""),
                    paste(current_col_label, "major1_Descr_New", sep=""),
                    paste(current_col_label, "major2_Descr_New", sep=""),
                    paste(current_col_label, "major3_Descr_New", sep=""))
  
  # For the first 4 new columns
  # That is: "T_n_Term_Code", "T_n_Unit_Load", "T_n_Lived_On_Campus",
  # and "T_n_Num_Tutoring_Visits"
  for (ts_col in 1:4) {
    
    # Copy and paste the corresponding data from cleaned and reordered_data
    pivoted[current_entry, current_cols[ts_col]] <- cleaned_and_reordered[current_row, (length(static_data) + ts_col)]
  }
  
  # Enter a new major in the corresponding "new major" columns
  # if the student changed their major at the end of a term
  # Otherwise, fill the spot with NA
  if (current_major1 != cleaned_and_reordered[current_row, "major1_Descr"]) {
    
    # the number is the index of the "major1_Descr_New" string in current_cols
    pivoted[current_entry, current_cols[5]] <- cleaned_and_reordered[current_row, "major1_Descr"]
    current_major1 <- cleaned_and_reordered[current_row, "major1_Descr"]
  } else {
    pivoted[current_entry, current_cols[5]] <- NA
  }
  
  if (is.na(current_major2)) {
    
    # the number is the index of the "major2_Descr_New" string in current_cols
    if (!is.na(cleaned_and_reordered[current_row, "major2_Descr"])) {
       pivoted[current_entry, current_cols[6]] <- cleaned_and_reordered[current_row, "major2_Descr"]
       current_major2 <- cleaned_and_reordered[current_row, "major2_Descr"]
     } else {
       pivoted[current_entry, current_cols[6]] <- NA
     }
     
  } else {
     
     if ((is.na(cleaned_and_reordered[current_row, "major2_Descr"])) || (current_major2 != cleaned_and_reordered[current_row, "major2_Descr"])) {
       pivoted[current_entry, current_cols[6]] <- cleaned_and_reordered[current_row, "major2_Descr"]
       current_major2 <- cleaned_and_reordered[current_row, "major2_Descr"]
     } else {
       pivoted[current_entry, current_cols[6]] <- NA
     }
     
  }
   
  if (is.na(current_major3)) {
   
    # The number is the index of the "major3_Descr_New" string in current_cols
   if (!is.na(cleaned_and_reordered[current_row, "major3_Descr"])) {
      pivoted[current_entry, current_cols[7]] <- cleaned_and_reordered[current_row, "major3_Descr"]
      current_major3 <- cleaned_and_reordered[current_row, "major3_Descr"]
   } else {
      pivoted[current_entry, current_cols[7]] <- NA
   }
   
 } else {
    
    if ((is.na(cleaned_and_reordered[current_row, "major3_Descr"])) || (current_major3 != cleaned_and_reordered[current_row, "major3_Descr"])) {
      pivoted[current_entry, current_cols[7]] <- cleaned_and_reordered[current_row, "major3_Descr"]
      current_major3 <- cleaned_and_reordered[current_row, "major3_Descr"]
    } else {
      pivoted[current_entry, current_cols[7]] <- NA
    }
    
 }
  
  # Move on to the next term
  current_term <- current_term + 1
}
```

### Data Subsetting

Binning, Down-sampling

`Tutoring_All` was created by summing up the total number of tutoring
visits the student attended across the number of terms they were
enrolled in. These numbers were categorized into No tutoring, low (1 to
5 visits), moderate (6 to 10) and high (over 11 visits).

## Descriptive Statistics

```{r}
#| message: false
#| warning: false
#| include: false
library(tidyverse)
library(plotly)
ddata <- pivoted
```

```{r}
#| message: false
#| warning: false
#| include: false
# Removes NA Values and sums rows for each student if over 1
BinaryChecker <- function(x) { 
              x[is.na(x)] <- 0
              as.integer(rowSums(x) > 0)
}
# Removes NA Values and sums rows for each student
SummaryChecker <- function(x) { 
              x[is.na(x)] <- 0
              as.integer(rowSums(x))
}
# Recodes Gender to binary 
  ddata$Gender <- as.character(ddata$Gender)
  ddata$Gender_Binary <- recode(ddata$Gender,
                                "Man" = "0",
                                "Woman" = "1",
                                .default = "1"
  )
  
ddata$Did_Graduate <- as.character(ddata$Did_Graduate)
ddata$Did_Graduate <- recode(ddata$Did_Graduate,
                            "No" = 0,
                            "Yes, with another major" = 0,
                            "Yes, with CS/IT/EMEC" = 1,
)


#Runs Binary/Summary Checker
ddata$Did_Graduate <- BinaryChecker(ddata[, grep("_Graduate$", names(ddata))])
ddata$Units_All <- SummaryChecker(ddata[, grep("_Unit_Load$", names(ddata))])
ddata$Housing_All <- BinaryChecker(ddata[, grep("_Lived_On_Campus$", names(ddata))])
ddata$Tutoring_All <- SummaryChecker(ddata[, grep("_Tutoring_Visits$", names(ddata))])

# Adds & Calculates Terms Attended
ddata <- ddata %>% 
        rowwise() %>% 
        mutate(Terms_Attended = sum(!is.na(c_across(ends_with("_Unit_Load"))))) %>%
        ungroup()

sdata <- ddata
```

### Sample #1

Descriptive analyses were conducted to summarize the characteristics of
those in the first sample. Our sample included a total of 1,091
students, with 84.4% males (*n* = 921) and 15.6% females (*n* = 169).
Additionally, 60.9% of our sample identified as being Non-Hispanic (*n*
= 664) and 39.1% identified as being Hispanic (*n* = 427). About half of
the students did not transfer (54.1%; *n* = 590), with the other half
transferring (45.9%; *n* = 501).

In regards to students' class taking habits, the average units taken per
term was 11.42 while students stayed an average of 5.23 terms (*SD* =
3.11). Within the department, 73.9% majored in Computer Science, 16.7%
majored in Information Technology, and the remaining 4% majored in
Mechatronics Engineering. Now that we have a better understanding of our
sample, we will explain the background of our statistical analyses.

```{r}
#| column: screen-inset-shaded
#| layout-nrow: 1
# Gender Plot
ggplot(sdata, mapping = aes(x = fct_infreq(Gender_Binary), fill = Gender_Binary)) + 
      geom_bar() +
      scale_fill_manual(values= c("#E798A1","#A90806","#A90806","#E798A1"), guide="none") +
      labs(x = "Gender", y = "Number of Students") + 
      geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5)

# Hispanic Plot
ggplot(sdata, mapping = aes(x = Is_Hispanic, fill = Is_Hispanic)) + 
      geom_bar() +
      labs(x = "Hispanic Staus", y = "Number of Students") +
      scale_fill_manual(values= c("#A90806","#E798A1"), guide="none") +
      scale_x_discrete(labels=c("Non-Hispanic", "Hispanic")) +
      geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5)

# Transfer Plot
ggplot(sdata, mapping = aes(x = fct_infreq(Is_Transfer), fill = Is_Transfer, group = Is_Transfer)) +
      geom_bar() +
      labs(x = "Transfer Status", y = "Number of Students") +
      scale_fill_manual(values= c("#E798A1","#A90806"), guide="none") +
      scale_x_discrete(labels=c("Non-Transfer","Transfer")) +
      geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5) 

# Lived on Campus
ggplot(sdata, mapping = aes(x = Housing_All, fill = Housing_All)) +
      geom_bar() +
      labs(x = "Lived On Campus (Throughout Education)", y = "Number of Students") +
      scale_fill_manual(values= c("#A90806","#E798A1"), guide="none") +
      scale_x_discrete(labels=c("Off-Campus","On-Campus")) +
      geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5) 
  
# Graduation 
ggplot(sdata, mapping = aes(x = Did_Graduate_Binary, fill = Did_Graduate_Binary)) +
      geom_bar() +
      scale_fill_manual(values= c("#A90806","#E798A1"), guide="none") + 
      labs(x = "Graduation Status", y = "Number of Students") +
      geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5) 

# Tutoring Binned
ggplot(sdata, mapping = aes(x = Tutoring_Binned, fill = Tutoring_Binned)) +
      geom_bar() +
      labs(x = "Student Status (Based on Units)", y = "Number of Students") +
      scale_fill_manual(values = c("#E798A1", "#A90806", "#E798A1", "#A90806"), guide = "none") +
      geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5)   
  
# Student Status (Units)
ggplot(sdata, mapping = aes(x = Binned, fill = Binned)) +
      geom_bar() +
      scale_fill_manual(values= c("#E798A1", "#A90806", "#E798A1"), guide = "none") + 
      labs(x = "Student Status (Based off Units)", y = "Density",) + 
      geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5)

# Units Density Plot  
ggplot(sdata, mapping = aes(x = Units_All)) +
      geom_density(adjust = 1L, fill = "#F6A6B0") +
      labs(x = "Units Taken", y = "Density",
      title = "Density of Units Taken") +
      theme(plot.title = element_text(size = 18L, hjust = 0.5),
            axis.title.y = element_text(size = 15L),
            axis.title.x = element_text(size = 15L))
```

### Sample #2

# Statistical Analyses

### Chi-Square

#### Theory

#### Assumptions

### Logistic Regression

#### Theory

#### Assumptions

### Survival Analysis

#### Theory

Survival Analysis is a category of statistical methods in which the
variable being studied is measured until a certain event occurs,
allowing for unique observations to be pulled from the data (Kleinbaum &
Klien, 2012). Survival analysis can account for participants who drop
out of the study prematurely before completing the event of interest. By
accounting for this group, survival analysis can have a larger sample
size and often explain more variance in the dependent variable. As
mentioned, there are many types of survival analyses, but the analysis
used in our study is the Cox Proportional Hazards Model.

The Cox Proportional Hazards Model is a semiparametric test that enables
statisticians to account for variables that affect the outcome of
interest otherwise known as their survival time (Kleinbaum & Klien,
2012). Due to its semiparamteric nature, it allows for a non-normal
distribution of the baseline hazard function, enabling the use of time
as a variable. Additionally, allows statisticians to account for
time-varying predictor variables, not just variables measured at the
beginning of a study. Its formula is as follows:

$h(t|\mathbf{X}) = h_0(t)\overset{\sum_{}X\mathrm{}_{i}\boldsymbol{\beta}\mathrm{}_{i}}{\mathrm{e}^{i = 1}}$

The $h(t|\mathbf{X})$ portion of the equation refers to hazard rate at a
certain time for individuals, meaning their likelihood of the outcome of
interest. $h_0(t)$ refers to the baseline hazard rate at a given time,
with
$\overset{\sum_{}X\mathrm{}_{i}\boldsymbol{\beta}\mathrm{}_{i}}{\mathrm{e}^{i = 1}}$
being a linear combination of each covariate (predictor variable) along
with their coefficient (${\beta}\mathrm{}_{i}$). The coefficient tells
us the change in log-hazard ratio for a one unit change in the covariate
($X\mathrm{}_{i}$). Now that we understand the formula, the assumptions
will be examined.

#### Assumptions

As with most statistical methods, there are a few assumptions that the
Cox Proportional Hazards model must meet before its use (Kleinbaum &
Klien, 2012). First, the hazard ratio must be the same over the period
of time, meaning that the effect a covariate has on the survival
likelihood must be the same across time. Second, observations must be
independent of each other, meaning that one participant's drop-out does
not affect the likelihood of another dropping out. Third, censoring must
be non-informative. This assumption says that censoring must be
independent, meaning no group has preferential attrition due to the
event of interest. Lastly, it is assumed that the predictors have a
linear relationship with the log hazard rate, and there is no
multicollinearity among them. Now that we have discussed the backgrounds
to the statistics we will be using, lets look at how they worked on our
dataset.

# Results

## Sample #1

### Inferential Statistics

Computer science programs have historically under-represented women and
non-binary populations. This same relationship can be seen from the data
from Channel Islands. Recall that due to the small sample size of
non-binary (*n* = 1), their value was re-coded as being female.

```{r}
#| message: false
#| warning: false
mdata <- ddata[ddata$Gender_Binary == 0, ]
fdata <- ddata[ddata$Gender_Binary == 1, ]
```

It was found that both males and females stay at Channel Islands roughly
the same amount of terms with males staying 5.11 terms and females
staying 5.59 terms on average. A t-test determined a non-significant
difference between the two groups (*p* \> .05).

```{r}
#| eval: false
#| message: false
#| warning: false
#| paged-print: true
mean(mdata$Terms_Attended) # Male Terms Mean
mean(fdata$Terms_Attended) # Female Terms Mean
t.test(mdata$Terms_Attended, fdata$Terms_Attended, alternative = "two.sided", var.equal = FALSE, conf.level = 0.95)
```

Graduation rates were found to be non-significantly different (*p* \>
.05), with males graduating 44.76% of the time and females 42.24% of the
time across all terms.

There is a significant association between gender and the likelihood of
graduating (*p* \< .01), with fewer females graduating (n = 339)
compared to males, and more females did not graduate compared to males
(n = 1577).

```{r}
#| echo: true
t.test(mdata$Did_Graduate, fdata$Did_Graduate, alternative = "two.sided", var.equal = FALSE, conf.level = 0.95)
chi_gender_grad <- table(ddata$Gender_Binary, ddata$Did_Graduate)
chi_gender_grad_result <- chisq.test(chi_gender_grad)
```

#### Hispanic Status

Due to Channel Islands being a Hispanic Serving Institution (HSI),
exploration of students' Hispanic Status was important to the researchers. The
following chart showcases the makeup of Hispanic and Non-Hispanic
students in the Computer Science Department.

```{r}
#| message: false
#| warning: false
nhisdata <- ddata[ddata$Is_Hispanic == 0, ]
hisdata <- ddata[ddata$Is_Hispanic == 1, ]
```

Students from both identity statuses attended same amount of terms
(*Winter, Fall, Spring, Summer*) with non-Hispanic students attending a
mean of 5.638 terms and Hispanic students 5.370. A two sided t-test
determined no significant difference between the two groups (*p* \>
.05).

```{r}
#| eval: false
mean(nhisdata$Terms_Attended) # Non-Hispanic Terms Mean
mean(hisdata$Terms_Attended) # Hispanic Terms Mean
t.test(hisdata$Terms_Attended, nhisdata$Terms_Attended, alternative = "two.sided", var.equal = FALSE, conf.level = 0.95)
```

Hispanic students were found to graduate 37.5% of the time, whereas
their Non-Hispanic counterparts graduated 49.3% of the time. Further
examination revealed a significant difference in graduation rate among
the two groups, *t*(1449)= 4.73, *p* \< .001.

```{r}
#| eval: false    
summary(nhisdata$Did_Graduate) # Non-Hispanic Graduation Mean
summary(hisdata$Did_Graduate) # Hispanic Graduation Mean
t.test(nhisdata$Did_Graduate, hisdata$Did_Graduate, alternative = "two.sided", var.equal = FALSE, conf.level = 0.95)
```

The intersection of the aforementioned findings indicate that Hispanic
and Non-Hispanic students attend the same amount of terms, but Hispanic
students graduate at a significantly lower rate.

#### Transfer Status

Channel Islands receives lots of transfer students due to the institution's well-established relationships
with local community colleges and the institution's relatively
low cost. This is supported by the data we received below.

```{r}
#| message: false
#| warning: false
hdata <- ddata[ddata$Is_Transfer == 0, ]
tdata <- ddata[ddata$Is_Transfer == 1, ]
```

It was found that student's who started their academic journey at
Channel Islands attend more terms (*M* = 5.96) than those who transfer
(*M* = 5.15) with a significant difference, *t*(1282) = 4.957, *p* \<
.001. Interestingly, this difference was not as large as expected as
those who transfer should theoretically need far less classes than those
who start at the institution.

```{r}
#| message: false
#| warning: false
#| eval: false
summary(hdata$Terms_Attended) # Home Terms Mean
summary(tdata$Terms_Attended) # Transfer Terms Mean
t.test(tdata$Terms_Attended, hdata$Terms_Attended, alternative = "two.sided", var.equal = FALSE, conf.level = 0.95)
```

When taking into account graduation rates, the lack of disparity between
terms attended for transfer and non-transfer student becomes apparent.
Students who started at Channel Islands graduate 35.61% of the time
whereas those who transfer graduate 51.98% of the time. A t-test
determined that this was a significant difference, *t*(1552) = 6.61, *p*
\> .001.

```{r}
#| eval: false
#| message: false
#| warning: false
summary(hdata$Did_Graduate) # Home Graduation Mean
summary(tdata$Did_Graduate) # Transfer Graduation Mean
t.test(tdata$Did_Graduate, hdata$Did_Graduate, alternative = "two.sided", var.equal = FALSE, conf.level = 0.95)
```

#### Majors

The Computer Science Department at Channel Islands includes the majors
of Computer Science, Mechatronics and Information Technology. Due to
some students double majoring or changing programs the data includes
majors that are outside this category.

Our major count was:

```{r}
#| echo: false
#| message: false
#| warning: false
dfmajor <- as.data.frame(c(ddata$major1_Descr, ddata$major2_Descr, ddata$major3_Descr)) # Combines student's majors into a DF
dfmajor <- dfmajor %>% # Removes NA Values
            na.omit(mutate(dfmajor = str_trim(c(ddata$major1, ddata$major2, ddata$major3))))
colnames(dfmajor) <- c("Major") # Renames Column
dfmajor <- dfmajor %>% # Creates count of majors
            count(Major)
print(dfmajor)
dfmajor <- dfmajor[dfmajor$n > 20, ] # Removes major with under 20 students
```

Due to the small sample size, majors with under 20 students were
excluded for the following chart:

#### Gender and Hispanic Status

It was found that Hispanic males graduate **39.44%** of the time,
whereas their Non-Hispanic male counterparts graduate **48.54%** of the
time. Similarly, Hispanic females graduate **29.13%** of the time and
Non-Hispanic females graduate **53.33%** of the time. This showcases a
large disparity between Hispanic and Non-Hispanic students. In addition,
there is a **\~10%** difference in graduation rates among Hispanic males
and females, whereas this disparity is not seen in their Non-Hispanic
counterparts.s

```{r}
#| eval: false
#| message: false
#| warning: false
  mhisdata <- mdata[mdata$Is_Hispanic == 1, ] # Male Hispanic 
  fhisdata <- fdata[fdata$Is_Hispanic == 1, ] # Female Hispanic
  
  mnhisdata <- mdata[mdata$Is_Hispanic == 0, ] # Male Not Hispanic
  fnhisdata <- fdata[fdata$Is_Hispanic == 0, ] # Female Not Hispanic
  
  # Gender by Hispanic Status
    summary(mhisdata$Did_Graduate) # Male Hispanic 0.3944
    summary(fhisdata$Did_Graduate) # Female Hispanic 0.2913
    
    summary(mnhisdata$Did_Graduate) # Male Not Hispanic: 0.4854
    summary(fnhisdata$Did_Graduate) # Female Not Hispanic: 0.5333
```

### Logistic Regression

### Survival Analysis

*Important Note: The Cox Proportional Hazards Model was incorrectly
implemented to this dataset due to the assumption of non-informative censoring being broken. Regardless, it was left in to test the
analysis on the dataset in the pursuit of learning.*

The Cox Proportional Hazards model was run on the event of graduation,
with the covariates of number of tutoring visits, Hispanic status,
gender, lived on campus, and transfer status.

```{r}
# Cox Proportional Hazards Model w/All Variables 
CoxAll <- coxph(Surv(time = start, time2 = stop, event = Did_Graduate_Binary) 
              ~  Num_Tutoring_Visits + Is_Hispanic + Gender_Binary + Lived_On_Campus + Is_Transfer, 
              data = sdata) 
CoxAll |> 
  tbl_regression(exp = TRUE)
summary(CoxAll) 
```

It was found that number of tutoring visits was significant (*p* \<
.01), with every tutoring visit indicating a 3.06% decrease in the
hazard of graduation. It was also found that Hispanic students hazard of
graduating is about 17.97% lower than that of Non-Hispanic Students (*p*
\< .05). Lastly, transfer students were found to have a increase of
300.97% in their hazard of graduation compared to those who were not
transfer students (*p* \< .001). Overall the model has good predictive
ability with a concordance of 0.736 (*SE* = 0.012), and fit the data
quite well χ²(4, N = 5617) = 206.9, *p* \< 0.001.

```{r}
# Checking the Proportional Hazards Assumption
PHA <- cox.zph(CoxAll, global = FALSE)
print(PHA)
plot(PHA) 
```

Regarding our assumptions, we did not meet the proportional hazards
assumption for all of our predictors. The predictors of transfer status
and lived on campus status were both significant, indicating that our
hazard ratios changed over time. This can be seen in the above charts,
with beta values changing over time for the aforementioned predictors.
Additionally, the assumption of censoring being non-informative was
broken as well. This was due to the fact that graduation did have an
impact on student's censoring with dropping out being a specific
subgroup of interest. Regardless of assumptions, the Kaplan-Meier curve
was included for learning.

```{r}
# All Variables Fit Graph
survival_fit <- survfit(CoxAll)
ggsurvplot(survival_fit, data = ddata, conf.int = TRUE, color = "#2E9FDF",
          xlab = "Time", ylab = "Survival Probability",
          title = "Survival Curves from Cox Proportional Hazards Model")

# Gender Fit
CoxGen <- survfit(Surv(start, stop, Did_Graduate_Binary) ~ Lived_On_Campus, data = ddata)
summary(CoxGen)
ggsurvplot(CoxGen, data = ddata, conf.int = TRUE, 
            xlab = "Time", ylab = "Survival Probability",
            title = "Survival Curves (Gender)")
```

The above Kaplan-Meier curve shows the overall survival probability for
our sample. The curves can be interpreted with *time on the bottom, and
the probability of survival on the left. The curves indicate small
differences in survival time for most predictors, whereas transfer
status shows a large difference because the curves are* far apart.

## Sample #2

### Inferential Statistics

#### Hispanic Status

#### Transfer Status

#### Majors

### Logistic Regression

# Discussion

Results (colorful language), Possible intervention demographics,
limitations, and future directions.

# Other

## References

Kleinbaum, D., & Klien, M. (2012). *Survival Analysis: A Self‐Learning
Text*. Springer.

## Acknowledgements

A big thanks to Dr. Kreshenko for giving us the platform to be able to
conduct this research. Her continued support helped us

```{r}
#                      /^--^\     /^--^\     /^--^\
#                      \____/     \____/     \____/
#                     /      \   /      \   /      \
#                    |        | |        | |        |
#                     \__  __/   \__  __/   \__  __/
#|^|^|^|^|^|^|^|^|^|^|^|^\ \^|^|^|^/ /^|^|^|^|^\ \^|^|^|^|^|^|^|^|^|^|^|^|
#| | | | | | | | | | | | |\ \| | |/ /| | | | | | \ \ | | | | | | | | | | |
#| | | | | | | | | | | | / / | | |\ \| | | | | |/ /| | | | | | | | | | | |
#| | | | | | | | | | | | \/| | | | \/| | | | | |\/ | | | | | | | | | | | |
##########################################################################
#| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |
#| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |
```
